__NUXT_JSONP__("/handling-blank-wkwebviews", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj){return {data:[{article:{slug:"handling-blank-wkwebviews",title:"Handling Blank WKWebViews",summary:"iOS's WKWebview is a massive improvement over the now-deprecated UIWebView, but I've noticed that they occasionally fail to render, seemingly at random times. Read on for how I've dealt with this issue, and what you can do about it.",shouldShowTableOfContents:true,shouldShowUpdatedAt:false,createdAt:"2020-12-12T00:00:00.140Z",tags:[av,aw],toc:[{id:ax,depth:X,text:ay},{id:az,depth:X,text:aA},{id:aB,depth:aC,text:aD},{id:aE,depth:aC,text:aF},{id:aG,depth:X,text:aH},{id:aI,depth:X,text:aJ}],body:{type:"root",children:[{type:b,tag:l,props:{},children:[{type:a,value:"If you simply want to see how I've handled WKWebViews rendering as white screens, go to the \"My Solution\" section. But I recommend you read this entire post if you want a full understanding of the issue and its solutions."}]},{type:a,value:f},{type:b,tag:Y,props:{id:ax},children:[{type:b,tag:w,props:{href:"#how-wkwebviews-work",ariaHidden:C,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:ay}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"Many teams have had the displeasure of being forced to migrate from UIWebViews to WKWebViews. While the amount of work is not trivial, I think that the changes themselves are relatively straightforward, and usually bring with them memory and speed improvements."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"There's something "},{type:b,tag:B,props:{},children:[{type:a,value:"very"}]},{type:a,value:" different, however, about WKWebViews when compared to UIWebViews:\n"},{type:b,tag:K,props:{},children:[{type:a,value:"When you initialize a WKWebView, a process "},{type:b,tag:B,props:{},children:[{type:a,value:"outside"}]},{type:a,value:" of your application's main process gets created."}]}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"This external process manages the rendering of your web content, and exists separate from your app's main process. You can actually see WKWebView's process when running your app in an XCode simulator: start your app, initialize a view that instantiates a WKWebView, and look in Activity Monitor for something with the name \"WebContent\" in it. You'll notice that, if you kill the process, your app's webview will turn blank (this is a great way to test your failure handling logic!)."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"That process's memory doesn't count towards the memory that your app uses, so if your webview uses a lot of memory, your app won't necessarily get killed or receive a memory warning. Instead, iOS will simply kill the WebContent process."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"On one hand, this is great because the death of a webview process doesn't necessarily mean the death of your entire app. But the downside is that, when problems occur with your WKWebView instances, your code will need to be able to gracefully handle these failure scenarios. Otherwise, when a WKWebView crashes, your users will often see an ugly, blank white screen."}]},{type:a,value:f},{type:b,tag:L,props:{className:["imageContainer"]},children:[{type:a,value:x},{type:b,tag:"img",props:{className:[],":src":"'\u002Fblankwkwebview.jpg'"},children:[]},{type:a,value:x},{type:b,tag:c,props:{className:["titleImageCaption","text--secondary"]},children:[{type:a,value:"An iOS component that uses WKWebView in the center to display information. It has just crashed, which is why it's just a white rectangle. "},{type:b,tag:w,props:{href:"https:\u002F\u002Fblog.embrace.io\u002Fbug-of-the-month-blank-webviews\u002F"},children:[{type:a,value:"Taken From embrace.io"}]}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"Even if your iOS and HTML\u002FJS code is "},{type:b,tag:w,props:{href:"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=UigzN-4JR14",rel:[O,P,Q],target:R},children:[{type:a,value:"simple and clean"}]},{type:a,value:", there are certain scenarios that will prompt iOS to "},{type:b,tag:B,props:{},children:[{type:a,value:"kill your webview"}]},{type:a,value:". Unhelpfully, Apple doesn't document "},{type:b,tag:B,props:{},children:[{type:a,value:aK}]},{type:a,value:" iOS would ever kill WebContent processes, but from my own testing, I think happens under the following scenarios:"}]},{type:a,value:f},{type:b,tag:aL,props:{},children:[{type:a,value:f},{type:b,tag:A,props:{},children:[{type:b,tag:K,props:{},children:[{type:a,value:"Low system memory"}]},{type:a,value:": if a device is running low on memory, iOS may deem it necessary to kill your webview. Note that your app delegate's "},{type:b,tag:u,props:{},children:[{type:a,value:"applicationDidReceiveMemoryWarning()"}]},{type:a,value:" function will NOT necessarily be called, since the webcontent process is seperate from your app's process."}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:b,tag:K,props:{},children:[{type:a,value:"Your app has been backgrounded"}]},{type:a,value:": just like how your safari tabs sometimes get killed when you've left them alone for a while, your app's webviews will sometimes get killed as well if your app has been left in the background, "},{type:b,tag:B,props:{},children:[{type:a,value:"even if your app itself hasn't been killed"}]},{type:a,value:i}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:b,tag:K,props:{},children:[{type:a,value:"Your webviews are not visible"}]},{type:a,value:": if you have a webview that's in a view controller, and that view controller is NOT on top of the view stack, iOS may deem it acceptable for killing. There's absolutely no documentation for this, but I have seen this happen many times in my own apps, especially when memory is low. iOS will prioritize the currently-displaying webview, while killing the ones not currently showing."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"One important note: when I mention memory problems as being a cause for iOS to kill webviews, I don't necessarily mean memory leaks. It could simply mean that your web pages are requesting too much memory, too quickly. Again, Apple doesn't mention any of this in their documentation. This is simply from what I've read and debugged."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:b,tag:K,props:{},children:[{type:a,value:"Sounds scary, right?"}]},{type:a,value:" Webviews randomly dying poses a major problem if the primary interface for your app is a webview. In particular, this is a an issue if you use web-view-based frameworks, such as Cordova or Ionic."}]},{type:a,value:f},{type:b,tag:Y,props:{id:az},children:[{type:b,tag:w,props:{href:"#how-wkwebviews-fail",ariaHidden:C,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:aA}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"In general, I found that there were two ways that WKWebView could fail, manifesting as a blank white screen:"}]},{type:a,value:f},{type:b,tag:"ol",props:{},children:[{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"The WebView rendering successfully, but iOS kills its WebContent process at some later point in time (i.e. after being backgrounded, or after returning into view after being invisible)."}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"The WebView never rendering at all."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:aM,props:{id:aB},children:[{type:b,tag:w,props:{href:"#killed-after-being-rendered",ariaHidden:C,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:aD}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"The first case, where the webview loads, but is then later killed, is the easy case. It can largely be attributed to iOS' aggressive memory management, and you can actually handle it pretty gracefully through the delegate callback "},{type:b,tag:u,props:{},children:[{type:a,value:"WKNavigationDelegate.webViewWebContentProcessDidTerminate"}]},{type:a,value:", which is documented "},{type:b,tag:w,props:{href:"https:\u002F\u002Fdeveloper.apple.com\u002Fdocumentation\u002Fwebkit\u002Fwknavigationdelegate\u002F1455639-webviewwebcontentprocessdidtermi",rel:[O,P,Q],target:R},children:[{type:a,value:"here"}]},{type:a,value:". I found that something simple like the following works pretty well (pseudo-code, don't copy and paste this):"}]},{type:a,value:f},{type:b,tag:L,props:{className:[S]},children:[{type:b,tag:T,props:{className:[U,Z]},children:[{type:b,tag:u,props:{},children:[{type:a,value:_},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ai}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:am},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:aN}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:V}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,W,t]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,ao,h]},children:[{type:a,value:ap}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:"\u002F\u002F Some other logic should probably go here"}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:"\u002F\u002F to try to restore state in the webview itself"}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:"\u002F\u002F as best as you can"}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:aO}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"When iOS terminates your webview, it invokes the delegate callback. When this happens, I found that calling "},{type:b,tag:u,props:{},children:[{type:a,value:"self.webview.reload()"}]},{type:a,value:" was enough to restore it. To get even fancier, you can do things like restore the scroll position with "},{type:b,tag:u,props:{},children:[{type:a,value:"self.webview.scrollView.setContentOffset()"}]},{type:a,value:", but the general idea should remain the same."}]},{type:a,value:f},{type:b,tag:aM,props:{id:aE},children:[{type:b,tag:w,props:{href:"#killed-before-being-rendered",ariaHidden:C,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:aF}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"The "},{type:b,tag:B,props:{},children:[{type:a,value:"second"}]},{type:a,value:" case of the webview simply showing a white screen from the get-go, however, is MUCH more difficult to track down and handle."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"The tricky part about this second case is that, unlike the first case, the "},{type:b,tag:u,props:{},children:[{type:a,value:M}]},{type:a,value:" delegate callback is usually NOT called. In addition, no other useful delegate callbacks are invoked either, such as memory warnings. Anecdotally, when I've encountered this issue, memory usage seemed fine, and I didn't see any crash reports or Jetsam Events in the device logs. This case would not happen very often: I would say that, on average, it would happen once for every 200 webview loads. And when I say \"loads\", I mean loading from a file on disk, so this rules out network failures."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"In the past, I used to think that the issue was due to some peculiarity of the app I was working on at the time, rather than WKWebView itself. But just to make sure, I built a simple test app that loads a WKWebView using an HTML file on disk over and over again, and alerts if the contents of the view are blank after some amount of buffer time (i.e. 5 seconds)."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"Sure enough, every single time I ran this app, I'd get the alert that the webview didn't load. Sometimes it would take 2 hours to see the alert. Sometimes it would take 10 minutes. Once, it took 6 hours. But sure enough, out of about 6 runs, it happened all 6 times."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"After pouring through the device logs (which were exhausting to look at), the only commonality that I saw between all six runs was the following error, right before iOS attempts set the WKWebView's process to foreground priority:"}]},{type:a,value:f},{type:b,tag:L,props:{className:[S]},children:[{type:b,tag:T,props:{className:[U,"language-text"]},children:[{type:b,tag:u,props:{},children:[{type:a,value:"RBSAssertionErrorDomain; code: 2; reason: \"Specified target process does not exist\".\n"}]}]}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"To me, this implies that iOS had killed the webview process before WKWebView could finish initializing. I know that the process was getting killed because I was able to trace the PID for the WebContent process in the logs: I could see it being created, and then later in the logs, I saw the error above saying that the target process doesn't exist."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"But as to "},{type:b,tag:B,props:{},children:[{type:a,value:aK}]},{type:a,value:" this was happening, I had no idea: perhaps the device had started the process, context-switched to do something else, and then switched back to the app, only to find that the WKWebView process had been killed. So then, why was the iOS delegate callback not being invoked? I had no idea, but perhaps it was because the code to initialize the delegate logic had not been initialized yet, either. But I had no way of knowing for sure."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"But I had stumbled upon "},{type:b,tag:w,props:{href:"https:\u002F\u002Fgithub.com\u002Fionic-team\u002Fcordova-plugin-ionic-webview\u002Fissues\u002F286",rel:[O,P,Q],target:R},children:[{type:a,value:"something interesting"}]},{type:a,value:": a setting on a private API that forces the webview to always run at foreground priority. Using private APIs usually makes apps ineligible to be submitted to the App Store, but I was curious to see if this would fix the issue in my test app. So, I added the following lines to my test app (again, pseudocode, but the idea remains the same):"}]},{type:a,value:f},{type:b,tag:L,props:{className:[S]},children:[{type:b,tag:T,props:{className:[U,Z]},children:[{type:b,tag:u,props:{},children:[{type:a,value:_},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:"\n  config"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"setValue"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,aP]},children:[{type:b,tag:c,props:{className:[d,aQ]},children:[{type:a,value:"\"TRUE\""}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:" forKey"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aP]},children:[{type:b,tag:c,props:{className:[d,aQ]},children:[{type:a,value:"\"alwaysRunsAtForegroundPriority\""}]}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"I ran my test app again for "},{type:b,tag:K,props:{},children:[{type:a,value:"24 hours"}]},{type:a,value:" and did not see the alert. So while I don't have definitive proof, I suspect that there is either a bug in WKWebView itself, or a race condition that goes something like this:"}]},{type:a,value:f},{type:b,tag:aL,props:{},children:[{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"a web view is initialized"}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"a process is spawned for the web view"}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"the process is backgrounded briefly because the webview isn't showing (hasn't yet been added to a parent view that's onscreen, or that paren't hasn't been yet been fully rendered)"}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"iOS sees this backgrounded process and says, \"eh, it's not being used, lets kill it\"."}]},{type:a,value:f},{type:b,tag:A,props:{},children:[{type:a,value:"The app is ready to show the webview but the process was just killed. Hence, none of the delegate callback stuff works."}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"If true, then this is why setting "},{type:b,tag:u,props:{},children:[{type:a,value:"alwaysRunsAtForegroundPriority"}]},{type:a,value:" fixes the problem. The WebContent process is never backgrounded, so that split-second opportunity for iOS to kill the process never happens, leaving your webview "},{type:b,tag:w,props:{href:"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=47dtFZ8CFo8",rel:[O,P,Q],target:R},children:[{type:a,value:"safe and sound"}]},{type:a,value:i}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"While this seems like an easy fix (it MAY also fix case #1 above, although I didn't test that), using that config option isn't a solution unless you're willing to risk getting banned from the App Store (and if that happens, where else are you gonna sell your app? That's an article for another day)."}]},{type:a,value:f},{type:b,tag:Y,props:{id:aG},children:[{type:b,tag:w,props:{href:"#my-solutions",ariaHidden:C,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:aH}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"So I decided to do something different: taking inspiration from "},{type:b,tag:w,props:{href:"https:\u002F\u002Fgithub.com\u002FIjzerenHein\u002FWKWebView\u002Fblob\u002Fmaster\u002Fsrc\u002Fios\u002FMyMainViewController.m",rel:[O,P,Q],target:R},children:[{type:a,value:"this snippet I found on GitHub"}]},{type:a,value:", I added logic to periodically check if the webview had died. It looked something like this (pseudo-code, don't copy and paste):"}]},{type:a,value:f},{type:b,tag:L,props:{className:[S]},children:[{type:b,tag:T,props:{className:[U,Z]},children:[{type:b,tag:u,props:{},children:[{type:a,value:_},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ai}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:am},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:aS}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:aT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:aU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aW]},children:[{type:a,value:aX}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,a_,a$]},children:[{type:a,value:ba}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:bb},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N,as]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:bc},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bd]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:aN}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:V}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,W,t]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:"\u002F\u002F TODO: There needs to be synchronization logic here: we don't want"}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:"\u002F\u002F webViewWebContentProcessDidTerminate firing twice!"}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:at}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:bf}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bi},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:V}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,W,t]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,ao,h]},children:[{type:a,value:ap}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:aO}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"Since my app was in complete control of its web content, I knew that every webview had a title. So if a webview DIDN'T have a title, then I knew that something had gone wrong, and I needed to reload the entire webview."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"This WOULD have worked well, but there was one problem! While "},{type:b,tag:u,props:{},children:[{type:a,value:bj}]},{type:a,value:" worked fine for the case where iOS was killing our WebContent process and invoking the delegate callback, I found that it didn't do ANYTHING for the second case! Calling "},{type:b,tag:u,props:{},children:[{type:a,value:bj}]},{type:a,value:" simply did nothing, which was extremely unfortunate. Instead, I found that I had to do something like the following:"}]},{type:a,value:f},{type:b,tag:L,props:{className:[S]},children:[{type:b,tag:T,props:{className:[U,Z]},children:[{type:b,tag:u,props:{},children:[{type:a,value:_},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:ai}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:aj}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:"\u002F\u002F ... Stuff I only want to initialize once"}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:au}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:"\n\n  function "},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:au}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:$}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:ae}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:D},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:ak},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:al},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:am},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:an},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:"\n\n\n    "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:at}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"!="}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N,as]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:"\n      "},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:"timer"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:"invalidate"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:aR},{type:b,tag:c,props:{className:[d,E]},children:[{type:a,value:aS}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ar},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:r}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:aT}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:aU}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:aV},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,aW]},children:[{type:a,value:aX}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:aY},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:aZ},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,a_,a$]},children:[{type:a,value:ba}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:a,value:ah},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:bb},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,N,as]},children:[{type:a,value:N}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:v}]},{type:a,value:bc},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,bd]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:V}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,W,t]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:at}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:ag},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:be},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:bf}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bg},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:bh},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:a,value:bi},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:G},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:V}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,W,t]},children:[{type:a,value:M}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,ao,h]},children:[{type:a,value:ap}]},{type:a,value:aq},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,q]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:a,value:g},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:m},{type:b,tag:c,props:{className:[d,h]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:i}]},{type:b,tag:c,props:{className:[d,t]},children:[{type:a,value:au}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:k}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:s}]},{type:a,value:x},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:z}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"If it's not clear, the difference between this snippet and the earlier one is that, instead of simple calling "},{type:b,tag:u,props:{},children:[{type:a,value:"reload()"}]},{type:a,value:" on the webview, I am constructing an entirely new webview, along with a new timer. This is undoubtedly a heavier solution, but I found that simply throwing the old webview away and creating a new one effectively worked around the issue."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"The end result of my solution is that, on the off chance that iOS kills my webviews and I actually get alerted about it, the view gets restored in a mostly-transparent fashion. When iOS kills my webview before I even get a chance to display it, this manifests to the user as a view that takes a little longer to load than normal."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"This sucks, but honestly, users are used to this. As an iphone\u002Fsafari user myself, pages randomly taking a long time to load is a daily occurrence for me. It's annoying and frustrating, and as a developer, you wish that there was a better alternative, but it is what it is."}]},{type:a,value:f},{type:b,tag:Y,props:{id:aI},children:[{type:b,tag:w,props:{href:"#summary",ariaHidden:C,tabIndex:H},children:[{type:b,tag:c,props:{className:[I,J]},children:[]}]},{type:a,value:aJ}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"This post isn't a dig at Apple (I'm sure it's the same, if not worse, for Android phones). It's just a reminder of how complicated these devices and their associated software can be, and the lengths that companies like Apple have gone to make programming for their devices as easy as possible. Want to display a web page in your app. Sure, it's three lines of code! Go crazy! It's commendable, but those abstractions can be leaky at times."}]},{type:a,value:f},{type:b,tag:l,props:{},children:[{type:a,value:"One final note: if anyone has any suggestions or improvements, "},{type:b,tag:B,props:{},children:[{type:a,value:"please"}]},{type:a,value:" include them in the comments below. I'd love to hear about your experiences with WKWebView, and how you've dealt with these problems (or maybe you've "},{type:b,tag:B,props:{},children:[{type:a,value:"never"}]},{type:a,value:" dealt with these problems, and I just write terrible code!)"}]}]},dir:"\u002Farticles",path:"\u002Farticles\u002Fhandling-blank-wkwebviews",extension:".md",updatedAt:"2025-05-23T02:54:32.425Z"},tags:{Essay:{slug:"essay",name:"Essay"},Anime:{slug:"anime",name:"Anime"},"How To":{slug:"howto",name:av},Gaming:{slug:"gaming",name:"Gaming"},Life:{slug:"life",name:"Life"},Reviews:{slug:"reviews",name:"Reviews"},Programming:{slug:"programming",name:aw}},prev:{slug:"beginners-guide-to-deep-learning-keras",title:"A Beginner's Guide to Deep Learning (Part 2)"},next:{slug:"game-companies-customer-crap-cyberpunk-2077",title:"Game Companies: Stop Treating your Customers Like Crap"}}],fetch:{},mutations:void 0}}("text","element","span","token","punctuation","\n"," ","keyword",".","(",")","p","\n    ","self",":","operator","class-name","=",";","function","code",",","a","\n  ","{","}","li","em","true"," configuration","comment","WKWebView","\n\n  ",-1,"icon","icon-link","strong","div","webViewWebContentProcessDidTerminate","nil","nofollow","noopener","noreferrer","_blank","nuxt-content-highlight","pre","line-numbers","func","function-definition",2,"h2","language-swift","  ","let"," configuration ","WKWebViewConfiguration","webView ","frame","CGRect","zero","webview","checkForDeadWebViews","public","init","\n    webview","navigationDelegate ","webview "," webview","omit","_"," webView","timer ","constant","if","initializeWebView","How To","Programming","how-wkwebviews-work","How WKWebViews Work","how-wkwebviews-fail","How WKWebViews Fail","killed-after-being-rendered",3,"Killed After Being Rendered","killed-before-being-rendered","Killed Before being Rendered","my-solutions","My Solution(s)","summary","Summary","why","ul","h3","...","reload","string-literal","string","\n\n    ","\u002F\u002F Every 3 seconds, check if the webview is dead. If it is, reload it.","Timer","scheduledTimer","timeInterval","number","3"," \n      target"," selector","other-directive","property","#selector","\n      userInfo"," repeats","boolean","title","?","isEmpty","\n       ","webView","webview.reload()")));